 1. Consider the function with three inputs (A,B,C) and two outputs (X,Y) that works like this:

          A  B  C | X  Y
         ---------+------
          0  0  0 | 0  1
          0  0  1 | 0  1
          0  1  0 | 0  1
          0  1  1 | 1  1
          1  0  0 | 1  0
          1  0  1 | 1  1
          1  1  0 | 1  0
          1  1  1 | 1  1
                    
Design two logic circuits for this function, one using AND, OR and NOT gates only, and one using NAND gates only. 
You DO NOT HAVE to draw the circuit, but it might be helpful to do that to visualize and trace the logic. However, 
for this question you are only required to write the four formulas — one for computing X and one for computing Y for each circuit type. 
They can take the form of a logical equation such as
X := A and B or such as Y := not-B and (A or C).
Using AND, OR, NOT:
X:= A OR B (B AND C)
Y:=  (NOT A) OR C

Using NAND:
X:= NAND(NAND(A,A), NAND(NAND(B,C), NAND(B,C)))
Y:= NAND(A, NAND(C,C))

2. Draw a logic circuit that compares two 2-bit signed numbers as follows. It should have four inputs a1, a0, b1, and b0. a1a0 is a 2-bit 
signed number (call it a) and b1b0 is a 2-bit signed number (call it b). The circuit has one output, c, which is 1 if a > b and 0 otherwise.

c := (NOTa1 AND b1) OR (NOTa1 AND a0 AND NOTb1) OR (a1 AND a0 AND b1 AND NOTb0)

3. Given a 32-bit register, write logic instructions to perform the following operations. For parts (c) and (f) assume an unsigned interpretation; 
for part (d) assume a signed interpretation. NOTE THAT THE STARTING VALUE OF THE REGISTER IS NOT IMPORTANT — your solution MUST WORK for any starting value.
Clear all even numbered bits.
Set the last three bits.
Compute the remainder when divided by 8.
Make the value -1
Complement the two highest order bits ['complement' means change the binary value to its opposite state — if it's a '1' it becomes a '0' and/or the other way round]
Compute the largest multiple of 8 less than or equal to the value itself [a multiple of 8 is a value that can be divided evenly by 8, like 16, 32, 48, 64, 80, etc.]

4. Write a simple C program to play the game fizz-buzz. This game lists all integer numbers from one to N in order, except for the following cases:
1) if a number is divisible by 3 the program should print fizz
2) if a number is divisible by 5 the program should print buzz
3) if a number is divisible by both 3 AND 5 the program should print fizz-buzz
4) all other cases should simply print the number
Make your program ask the user for the value of N. Be sure to check for errors in the entry; for example, entering a zero or a negative number.

5. For the sample Stanley/Penguin single-accumulator computer discussed in class, write a complete assembly language program in the Stanley/Penguin language that sends 
the values 0 through 255 out to port 0x8. NOTE: the machine code for this will be written in the next problem.

6. Translate your Stanley/Penguin language program in the previous problem to machine language.

7. For the sample single-accumulator computer discussed in class, write a complete assembly language program in the stanley/penguin language that computes a greatest common divisor. 
Assume the two inputs are read in from port 0x100. Write the result to port 0x200. You do not need to write machine code for this problem.

8. For the sample single-accumulator computer discussed in class, give a code fragment, in assembly language of the stanley/penguin language, that swaps the accumulator and memory address 0x30AA. 
You do not need to write machine code for this problem.

JMP start
temp1 : 0
temp2 : 0
start :   STORE [temp1]
LOAD 0x30AA
STORE [temp2]
LOAD [temp1]
STORE 0x30AA
LOAD [temp2]
end : JMP end	

9. For the sample single-accumulator computer discussed in class, give a code fragment, in assembly language of the stanley/penguin language that has the effect of jumping to the code 
at address 0x837BBE1 if the value in the accumulator is greater than or equal to 0. You do not need to write machine code for this problem.

JGZ start
JZ start
start : JMP 0x837BBE1

10. Part 1: Explain, at a high-level, what the following sequence of instructions does. In other words, suppose a programmer has stored data in r8 and r9. After executing these instructions, 
what does the programmer notice about the data? [HINT: It will help if you pick some binary values and walk through the operations.]
      xor r8, r9
      xor r9, r8
      xor r8, r9
                    
Part 2: Also state as briefly as possible why that effect happens.

The value stored at r8 will now be stored at r9 and the value stored at r9 will now be stored at r8. If we assume r8 is False and r9 is True, 
the first xor returns True or False to r8. The second xor will therefore return True or False or True (which is False) to r9. And the last 
xor will return False or True or False (which is True) to r8. Thus, at the end of the sequence, r8 and r9 have swapped values. 
